// Metadata: {"postTitle": "How JavaScript Engine works behind the scenes"}
import SharedDate from "../../context/dateContext";

const HowJSEngineWorks = () => {
  return (
    <article>
      <h2>How JavaScript Engine works behind the scenes</h2>
      <SharedDate.Consumer>
        {(value) => (
          <p>
            <i>
              <time>{value}</time>
            </i>
          </p>
        )}
      </SharedDate.Consumer>

      {/* SUMMARY */}
      <section>
        <p>
          <details>
            <summary>
              <abbr title="Too long; Didn't Read">TL;DR</abbr>
            </summary>
            <ol>
              <li></li>
              <li></li>
              <li></li>
            </ol>
          </details>
        </p>
      </section>

      {/* INTRO */}
      <section>
        <h3>Intro</h3>
        <p>
          Before we dive in, the actual implementation is much more complex and
          the post is missing out many other details.
          <br />
          Please consider this post as a high-level overview.
          <br />
          <br />
          Given we execute my clunky JS source code, how is it executed by
          engine?
          <br />
          Furthermore, is JavaScript <em>interpreted language</em> or{" "}
          <em>compiled language</em>?
          <br />
        </p>
        <p>
          First, All programming languages require some form of{" "}
          <em>' runtime environment '</em> to execute.
          <br />
          When it comes to Javascript, we'll come up with browser runtime
          environment(Google Chrome, Firefox) or Node.js runtime environment.
          <br />
          Both of runtime environments inherently have their own engines like{" "}
          <a href={"https://github.com/v8/v8"}>V8 </a>
          and SpiderMonkey. <br />
          And the engine we'll deal with in the post is, <strong>V8</strong>.
          <br />
          <br /> To correctly use high-level languages, understanding what's
          happening under the hood is cruical, as you know.
          <br /> Let's explore our high-level language, JavaScript.
        </p>
      </section>

      {/* BODY */}
      <section>
        <h3>Lexical Analysis</h3>
        <p>
          Lexer breaks <em>plain text</em> down to <strong>tokens</strong>.{" "}
          <br /> At this step it simply identifies the type of token each word
          belongs to.
          <br />
          When Lexer detects <code>const</code> as <em>plain text</em>, it
          assigns an Identity, transforming plain text into{" "}
          <em>meaningful element</em> in program with its own role,{" "}
          <code>VariableDeclaration</code> <br /> In summary, this abstraction
          layer plays a role of <strong>Tokenisation</strong>.
        </p>

        <h3>Syntax Analysis</h3>
        <p>
          From the tokens generated by lexer, parser will verify if the token
          follows the rule of source language, Javascript.
          <br /> Next it generates <strong>
            AST(Abstract Syntax Tree)
          </strong>{" "}
          which serves as the input for the interpreter. <br /> In sumamry, this
          abstraction layer builds{" "}
          <strong>
            {" "}
            a structural(hierarchial) representation of the verified input{" "}
          </strong>{" "}
          <br /> <br />
          For reference, in modern programming langauges, Lexer is commonly a
          component of Parser. As well as Lexer is, Parser might be a component
          of Interpreter. <br />
          <blockquote>
            <em>...The use of parsers varies by input</em>.<br />
            <em>
              ...In the case of programming languages, a parser is{" "}
              <strong>a component of</strong> a compiler or interpreter
            </em>
            <br /> -{" "}
            <a href={"https://en.wikipedia.org/wiki/Parsing#Parser"}>
              Wikipedia, Parsing
            </a>
          </blockquote>
        </p>
        <p style="display: grid; grid-template-columns: repeat(auto-fit, minmax(376px, 1fr));">
          <figure style="display: flex; flex-direction: column;">
            <img
              src="https://pub-2452da71d6134c44b7ad30442572bedc.r2.dev/V8_C++.png"
              alt="V8"
              loading="lazy"
              style="width: 100%; height: 100%; object-fit: contain;"
            />
            <figcaption>
              <code>V8</code> <br />
              <br />
              <em>
                V8 is <strong>C++ Program</strong> under the hood. Within this
                C++ program, we'll soon uncover what's happening under the hood.
              </em>
            </figcaption>
          </figure>
          <figure style="display: flex; flex-direction: column;">
            <img
              src="https://pub-2452da71d6134c44b7ad30442572bedc.r2.dev/AST.png"
              alt="AST"
              loading="lazy"
              style="width: 100%; height: 100%; object-fit: contain;"
            />
            <figcaption>
              <code>
                AST - <a href={"https://astexplorer.net/"}>AST Explorer</a>
              </code>{" "}
              <br />
              <br />
              <em>
                <strong>Tokens</strong> are hierarchial composing{" "}
                <strong>Tree</strong> data structure. Otherwise, they'll look
                flat within an array.
              </em>
            </figcaption>
          </figure>
        </p>
        <h3>Compilation Pipeline</h3>

        <p>
          <h4>1. Interpreter</h4>{" "}
          <blockquote>
            <em>
              With <strong>Ignition</strong>, V8 compiles JavaScript functions
              to a concise
              <strong> bytecode</strong>, which is between 50% to 25% the size
              of the equivalent
              <strong> baseline machine code</strong>. <br />-{" "}
              <a href="https://v8.dev/blog/ignition-interpreter">
                Firing up the Ignition interpreter
              </a>
            </em>
          </blockquote>{" "}
          Inside V8 engine, the interpreter is called{" "}
          <strong>
            <a href={"https://v8.dev/docs/ignition"}>Ignition</a>
          </strong>
          <br /> It traverses <em>AST</em>, that is to say, visiting each nodes
          and generating corresponding <strong>bytecode</strong>,{" "}
          <em>
            an <strong>intermediate representation</strong> between source code
            and machine code
          </em>
          .<br />
          <br />
          Generated bytecodes go through several steps of optimization again.{" "}
          <br />
          The Ignition interpreter uses{" "}
          <strong>
            TurboFan’s low-level, architecture-independent macro-assembly
            instructions
          </strong>{" "}
          to generate bytecode handlers for each opcode. <br />
          <br />
          Each <em>opcode</em> represents certain instructions like add or
          subtract.
          <br /> To match those <strong>bytecodes to opcodes</strong>,{" "}
          <code>IGNITION_HANDLER</code>, bytecode handlers are implemented.
          <br /> It is equal to say those optimized bytecodes will be passed to{" "}
          <strong>the interpreter within Ignition</strong> which untimately
          <strong> executes</strong> them.
          <br />
          <br /> Therefore, Ignition can be accurately described as both a{" "}
          <em>bytecode compiler</em> and an <em>interpreter</em>.
        </p>
        <p>
          <h4>2. Compiler</h4>Compiler implementation within V8 has evolved, and
          has been changing. As of 2025, V8 includes four compilers: Crankshaft,
          TurboFan, Sparkplug, and Maglev. <br /> V8 uses{" "}
          <em>a tiered compilation approach</em>, which means it compiles and
          executes several ways and its pipeline is highly likely to go through
          changes in future.
          <br />
          So the main interest is, to understand that V8 engine has{" "}
          <strong>multiple ways to execute bytecode</strong>(there might be more
          ways)
          <ol>
            <li>
              <em>
                It executes <strong>bytecode</strong> generated by Ignition
              </em>
              <br />- Interpreter within Ignition, as mentioned above. As a
              reminder, Ignition plays both roles of <em>bytecode compiler</em>{" "}
              and <strong>interpreter</strong> which{" "}
              <strong>executes bytecodes</strong>
            </li>
            <br />
            <li>
              {" "}
              <em>
                It converts bytecode into{" "}
                <strong>unoptimized machine code</strong>
              </em>
              <br />-<em> Baseline compiler</em> comes into a play here, the
              reason is - At the extremes of{" "}
              <em>compilation and interpretation</em>, compiler costs higher
              <strong> memory overhead</strong> and interpreter sacrifices{" "}
              <strong>execution speed</strong>.<br /> It will execute faster
              than interpreter does but it will be less optimized than
              optimization compiler. At the initial phase within V8 engine,
              monitor will analyze and choose which execution strategy to
              choose.
            </li>
            <br />
            <li>
              <em>
                It converts frequently used bytecode into{" "}
                <strong>optimized-machine code</strong>
              </em>{" "}
              <br />- TurboFan, optimising compiler converts '
              <em>frequently used bytecode</em>'(so-called 'hot code') delivered
              by monitor into native machine code.
            </li>
          </ol>
          <blockquote>
            <em>
              JIT compilation is a combination of the two traditional approaches
              to translation to machine code—ahead-of-time compilation (AOT),
              and interpretation—
              <br />-{" "}
              <a
                href={"https://en.wikipedia.org/wiki/Just-in-time_compilation"}
              >
                Wikipedia, Just-in-time compilation
              </a>
            </em>
          </blockquote>
        </p>
        <p style="display: grid; grid-template-columns: repeat(auto-fit, minmax(376px, 1fr));">
          <figure style="display: flex; flex-direction: column;">
            <img
              src="https://pub-2452da71d6134c44b7ad30442572bedc.r2.dev/BytecodeGenerator.png"
              alt="BytecodeGenerator"
              loading="lazy"
              style="width: 100%; height: 100%; object-fit: cover;"
            />
            <figcaption>
              <code>interpreter.cc</code> <br />
              <em>
                <br /> <code>InterpreterCompilationJob</code> initialises an
                interpreter with both roles of generating bytecode(Bytecode
                Compiler) and executing those bytecodes(Interpreter).
              </em>
            </figcaption>
          </figure>
          <figure style="display: flex; flex-direction: column;">
            <img
              src="https://pub-2452da71d6134c44b7ad30442572bedc.r2.dev/IgnitionHandlers.png"
              alt="IgnitionHandlers"
              loading="lazy"
              style="width: 100%; height: 100%; object-fit: contain;"
            />
            <figcaption>
              <code>interpreter-generator.cc</code> <br />
              <em>
                <br /> TurboFan's macro-assembly instructions are internally
                used 'to build Ignition'{" "}
              </em>
            </figcaption>
          </figure>
        </p>
      </section>

      {/* CONCLUSION */}
      <section>
        <h3>Conclusion</h3>

          <figure style="display: flex; flex-direction: column;">
            <img
              src="https://pub-2452da71d6134c44b7ad30442572bedc.r2.dev/V8EngineOverview.svg"
              alt="V8EngineOverview"
              loading="lazy"
              style="width: 100%; height: 50%; object-fit: contain;"
            />
            <figcaption>
              <code>V8 Engine high-level overview diagram</code> <br />
            </figcaption>
          </figure>
        <p>
          So far, we've come to discover how JS Engine works behind the scenes.
          But we still have a question unanswered I mentioned at the beginning.
          <blockquote>
            <em>Is JavaScript interpreted language or compiled language?</em>
          </blockquote>
          Node.js documentation perfectly answers to this question.
          <blockquote>
            <em>
              JavaScript is generally considered an interpreted language, but
              <strong> modern JavaScript engines</strong> no longer just
              interpret JavaScript, <strong>they compile it.</strong>
              <br />
              <br /> ...This might seem counter-intuitive, but since the
              introduction of Google Maps in 2004, JavaScript has evolved from a
              language that was generally executing a few dozens of lines of
              code to complete applications with thousands to hundreds of
              thousands of lines running in the browser.
              <br />
              <br /> ...In this new world, compiling JavaScript makes perfect
              sense because while it might take a little bit more to have the
              JavaScript ready, once done it's going to be much more performant
              than purely interpreted code. <br />
              <a
                href={
                  "https://nodejs.org/en/learn/getting-started/the-v8-javascript-engine"
                }
              >
                - Node.js documentation,The V8 JavaScript Engine
              </a>
            </em>
          </blockquote>
          <blockquote>
            <em>
              The basic difference is that '<strong>a compiler system</strong>',
              including a (built in or separate) linker, generates '
              <strong>a stand-alone machine code program</strong>', while '
              <strong>an interpreter system</strong>' instead '
              <strong>performs the actions</strong>' described by the high-level
              program.
              <br />
              <a
                href={
                  "https://en.wikipedia.org/wiki/Interpreter_(computing)#Compilers_versus_interpreters"
                }
              >
                - Wikipedia, Compilers versus interpreters
              </a>
            </em>
          </blockquote>
          Modern JavaScript engine is constantly evolving thanks to engineering
          teams working on it. <br />
          As the complexity of real-world application has increased, engineers
          brought up many solutions, of which tiered compilation approach was a
          part of it.
          <br />
          Thus, Javscript is{" "}
          <strong>no longer as purely dependent on interpretation</strong> as it
          was.
          <br />
          However it's still fair to call it an 'interpreted language' compared
          to languages that perfectly fit the traditional definition of compiled
          language(compiled ahead of time) such as C, C++, Rust.
        </p>
        <p>
          <em>Further Reading :<br /></em>
          <a>
            https://stackoverflow.com/questions/54957946/what-does-v8s-ignition-really-do/54962646#54962646
            <br />
          </a>
          <a>
            https://stackoverflow.com/questions/59638327/what-is-a-baseline-compiler
            <br />
          </a>
          <a>
            https://stackoverflow.com/questions/54957946/what-does-v8s-ignition-really-do
            <br />
          </a>
          <a>
            https://medium.com/@yanguly/sparkplug-v8-baseline-javascript-compiler-758a7bc96e84
            <br />
          </a>
        </p>
      </section>
    </article>
  );
};

export default HowJSEngineWorks;
